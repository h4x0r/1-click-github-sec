#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<USG
gitleakslite (script) - minimal secret scanner

Usage:
  gitleakslite protect --staged [--redact] [--no-banner] [--config PATH]
  gitleakslite detect [--redact] [--no-banner] [--config PATH]

USG
}

# Read allowlist patterns (simple EREs)
read_allowlist() {
  local file=".security-controls/secret-allowlist.txt"
  if [[ -f $file ]]; then
    cat "$file"
  fi
}

sanitize() {
  sed -E 's/([:=])[[:space:]]*"?[^"[:space:]]{4,}/\1 ***REDACTED***/g'
}

scan_lines() {
  local file="$1"
  local redact="$2"
  local allowlist
  allowlist=$(read_allowlist || true)
  local patterns='AKIA[0-9A-Z]{16}|ghp_[A-Za-z0-9]{36}|AIza[0-9A-Za-z_-]{35}|xox[baprs]-[A-Za-z0-9-]{10,48}|-----BEGIN [A-Z ,]*PRIVATE KEY-----|[A-Za-z0-9+/=]{40,}'
  local kw='(secret|password|api[_-]?key|token)'
  local hit=0
  while IFS= read -r line; do
    # skip allowlisted lines
    if [[ -n $allowlist ]] && grep -E -q "$allowlist" <<<"$line"; then continue; fi
    if grep -E -q "$patterns" <<<"$line" || grep -E -qi "$kw[^\n]{0,20}[:=][[:space:]]*[^[:space:]]{8,}" <<<"$line"; then
      if [[ $redact == "1" ]]; then
        echo "$line" | sanitize
      else
        echo "$line"
      fi
      hit=1
    fi
  done
  return $hit
}

cmd_protect() {
  local staged=0 redact=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --staged)
        staged=1
        shift
        ;;
      --redact)
        redact=1
        shift
        ;;
      --no-banner) shift ;;
      --config) shift 2 ;; # ignore
      -h | --help)
        usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1" >&2
        usage
        exit 2
        ;;
    esac
  done
  if [[ $staged -ne 1 ]]; then
    echo "protect: --staged required" >&2
    exit 2
  fi
  local dir_filter='^(target/|node_modules/|dist/|build/|vendor/|coverage/|\\.git/|\\.github/workflows/)'
  local hit=0
  while IFS= read -r f; do
    [[ -z $f || ! -f $f ]] && continue
    if ! git diff --cached -U0 -- "$f" | sed -n 's/^+//p' | scan_lines "$f" "$redact"; then
      hit=1
      echo "[$f]" >&2
    fi
  done < <(git diff --cached --name-only --diff-filter=ACM | grep -v -E "$dir_filter" || true)
  if [[ $hit -eq 1 ]]; then
    exit 1
  fi
}

cmd_detect() {
  local redact=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --redact)
        redact=1
        shift
        ;;
      --no-banner) shift ;;
      --config) shift 2 ;; # ignore
      -h | --help)
        usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1" >&2
        usage
        exit 2
        ;;
    esac
  done
  local dir_filter='^(target/|node_modules/|dist/|build/|vendor/|coverage/|\\.git/|\\.github/workflows/)'
  local hit=0
  while IFS= read -r f; do
    [[ -z $f || ! -f $f ]] && continue
    if ! cat "$f" | scan_lines "$f" "$redact"; then
      hit=1
      echo "[$f]" >&2
    fi
  done < <(git ls-files | grep -v -E "$dir_filter" || true)
  if [[ $hit -eq 1 ]]; then
    exit 1
  fi
}

main() {
  local cmd="${1:-}"
  shift || true
  case "$cmd" in
    protect) cmd_protect "$@" ;;
    detect) cmd_detect "$@" ;;
    "" | -h | --help) usage ;;
    *)
      echo "Unknown command: $cmd" >&2
      usage
      exit 2
      ;;
  esac
}

main "$@"
