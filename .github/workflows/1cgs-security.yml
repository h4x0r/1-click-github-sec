# ============================================================================
# ⚠️⚠️⚠️ AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY ⚠️⚠️⚠️
# ============================================================================
#
# 🚫 MANUAL EDITS TO THIS FILE WILL BE LOST ON NEXT UPGRADE
#
# This workflow is generated from:
#   - Template: 1cgs-security v3.0.0 (merged: security + pinning)
#   - Config: .security-controls/config.yml
#   - Installer: v0.9.0
#   - Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
#
# To customize this workflow:
#   1. Edit: .security-controls/config.yml
#   2. Run: ./install-security-controls.sh
#   3. Commit both files: config.yml + this workflow
#
# ⚠️⚠️⚠️ DO NOT EDIT THIS FILE DIRECTLY ⚠️⚠️⚠️
# ============================================================================

name: Security CI

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

env:
  CARGO_TERM_COLOR: always

jobs:
  security-audit:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")

    - name: Detect Rust packages
      id: rust
      run: |
        set -euo pipefail
        if [ -f Cargo.toml ]; then
          if grep -q '^[[:space:]]*\[package\]' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          elif grep -q '^[[:space:]]*\[workspace\]' Cargo.toml && grep -q '^[[:space:]]*members[[:space:]]*=' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi
        else
          echo "has=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Install Rust toolchain
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: dtolnay/rust-toolchain@$(get_action_sha "$DTOLNAY_RUST_TOOLCHAIN") # $(get_action_version "$DTOLNAY_RUST_TOOLCHAIN")
      with:
        toolchain: stable

    - name: Skip Security Audit (no Rust packages)
      if: ${{ steps.rust.outputs.has != 'true' }}
      run: echo "No Rust packages detected; skipping Security Audit job steps."

    - name: Cache dependencies
      if: \${{ steps.rust.outputs.has == 'true' }}
      uses: actions/cache@$(get_action_sha "$ACTIONS_CACHE_V4") # $(get_action_version "$ACTIONS_CACHE_V4")
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          target/
        key: ${{ runner.os }}-cargo-audit-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-audit-

    - name: Install cargo-audit and cargo-auditable
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        cargo install --locked cargo-audit
        cargo install --locked cargo-auditable

    - name: Build with auditable metadata
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: cargo auditable build --release

    - name: Run cargo audit
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: cargo audit

    - name: Run cargo audit for dependencies
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: cargo audit --db advisory-db --json | tee audit-report.json

    - name: Run cargo audit on binary
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: cargo audit bin target/release/*

    - name: Upload audit report
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: actions/upload-artifact@$(get_action_sha "$ACTIONS_UPLOAD_ARTIFACT_V4") # $(get_action_version "$ACTIONS_UPLOAD_ARTIFACT_V4")
      with:
        name: security-audit-report
        path: audit-report.json

  secret-scanning:
    name: Secret Scanning
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")
      with:
        fetch-depth: 0

    - name: Run Gitleaks
      uses: gitleaks/gitleaks-action@$(get_action_sha "$GITLEAKS_ACTION_V2") # $(get_action_version "$GITLEAKS_ACTION_V2")
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  vulnerability-scanning:
    name: Vulnerability Scanning
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")

    - name: Run Trivy vulnerability scanner in repo mode
      uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # 0.33.1
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results to GitHub Security
      uses: github/codeql-action/upload-sarif@$(get_action_sha "$GITHUB_CODEQL_ANALYZE_V3") # $(get_action_version "$GITHUB_CODEQL_ANALYZE_V3")
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  static-analysis:
    name: Static Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")

    - name: Detect Rust packages
      id: rust
      run: |
        set -euo pipefail
        if [ -f Cargo.toml ]; then
          if grep -q '^[[:space:]]*\[package\]' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          elif grep -q '^[[:space:]]*\[workspace\]' Cargo.toml && grep -q '^[[:space:]]*members[[:space:]]*=' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi
        else
          echo "has=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Initialize CodeQL
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: github/codeql-action/init@$(get_action_sha "$GITHUB_CODEQL_INIT_V3") # $(get_action_version "$GITHUB_CODEQL_INIT_V3")
      with:
        languages: rust
        queries: +security-and-quality

    - name: Install Rust toolchain
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: dtolnay/rust-toolchain@$(get_action_sha "$DTOLNAY_RUST_TOOLCHAIN") # $(get_action_version "$DTOLNAY_RUST_TOOLCHAIN")
      with:
        toolchain: stable

    - name: Build project
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: cargo build --release

    - name: Perform CodeQL Analysis
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: github/codeql-action/analyze@$(get_action_sha "$GITHUB_CODEQL_ANALYZE_V3") # $(get_action_version "$GITHUB_CODEQL_ANALYZE_V3")

  supply-chain:
    name: Supply Chain Security
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")

    - name: Detect Rust packages
      id: rust
      run: |
        set -euo pipefail
        if [ -f Cargo.toml ]; then
          if grep -q '^[[:space:]]*\[package\]' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          elif grep -q '^[[:space:]]*\[workspace\]' Cargo.toml && grep -q '^[[:space:]]*members[[:space:]]*=' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi
        else
          echo "has=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Install Rust toolchain
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: dtolnay/rust-toolchain@$(get_action_sha "$DTOLNAY_RUST_TOOLCHAIN") # $(get_action_version "$DTOLNAY_RUST_TOOLCHAIN")
      with:
        toolchain: stable

    - name: Generate SBOM
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        cargo install --locked cargo-auditable
        cargo auditable build --release
        cargo install --locked cargo-cyclonedx
        cargo cyclonedx --format json --output-file sbom.json

    - name: Skip Supply Chain (no Rust packages)
      if: ${{ steps.rust.outputs.has != 'true' }}
      run: echo "No Rust packages detected; skipping Supply Chain job steps."

    - name: Upload SBOM
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: actions/upload-artifact@$(get_action_sha "$ACTIONS_UPLOAD_ARTIFACT_V4") # $(get_action_version "$ACTIONS_UPLOAD_ARTIFACT_V4")
      with:
        name: software-bill-of-materials
        path: sbom.json


  license-compliance:
    name: License Compliance
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")

    - name: Detect Rust packages
      id: rust
      run: |
        set -euo pipefail
        if [ -f Cargo.toml ]; then
          if grep -q '^[[:space:]]*\[package\]' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          elif grep -q '^[[:space:]]*\[workspace\]' Cargo.toml && grep -q '^[[:space:]]*members[[:space:]]*=' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi
        else
          echo "has=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Install Rust toolchain
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: dtolnay/rust-toolchain@$(get_action_sha "$DTOLNAY_RUST_TOOLCHAIN") # $(get_action_version "$DTOLNAY_RUST_TOOLCHAIN")
      with:
        toolchain: stable

    - name: Install cargo-license
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: cargo install --locked cargo-license

    - name: Generate license report
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        cargo license --json > licenses.json
        cargo license --tsv > licenses.tsv

    - name: Check for copyleft licenses
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        COPYLEFT=$(cargo license --json | jq -r '.[] | select(.license | test("GPL-2.0|GPL-3.0|AGPL|LGPL"; "i")) | "\(.name): \(.license)"' || true)
        if [ -n "$COPYLEFT" ]; then
          echo "::warning::Copyleft licenses found:"
          echo "$COPYLEFT"
        else
          echo "No problematic copyleft licenses found"
        fi

    - name: Skip License Compliance (no Rust packages)
      if: ${{ steps.rust.outputs.has != 'true' }}
      run: echo "No Rust packages detected; skipping License Compliance job steps."

    - name: Upload license report
      uses: actions/upload-artifact@$(get_action_sha "$ACTIONS_UPLOAD_ARTIFACT_V4") # $(get_action_version "$ACTIONS_UPLOAD_ARTIFACT_V4")
      with:
        name: license-compliance-report
        path: |
          licenses.json
          licenses.tsv

  binary-analysis:
    name: Binary Security Analysis
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")

    - name: Detect Rust packages
      id: rust
      run: |
        set -euo pipefail
        if [ -f Cargo.toml ]; then
          if grep -q '^[[:space:]]*\[package\]' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          elif grep -q '^[[:space:]]*\[workspace\]' Cargo.toml && grep -q '^[[:space:]]*members[[:space:]]*=' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi
        else
          echo "has=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Install Rust toolchain
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: dtolnay/rust-toolchain@$(get_action_sha "$DTOLNAY_RUST_TOOLCHAIN") # $(get_action_version "$DTOLNAY_RUST_TOOLCHAIN")
      with:
        toolchain: stable

    - name: Build release binary
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: cargo build --release

    - name: Install binary analysis tools
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        cargo install --locked cargo-binutils
        rustup component add llvm-tools-preview

    - name: Analyze binary for embedded secrets
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        echo "🔍 Scanning binary for embedded secrets..."
        for binary in target/release/*; do
          if [[ -x "$binary" && ! -d "$binary" ]]; then
            echo "Analyzing: $binary"
            # Check for common secret patterns in binary
            if strings "$binary" | grep -i -E "(password|secret|token|api[_-]?key|private[_-]?key|-----BEGIN)" > binary-secrets.txt; then
              echo "::warning::Potential secrets found in binary"
              cat binary-secrets.txt
            else
              echo "✅ No obvious secrets found in binary"
            fi
          fi
        done

    - name: Check for debug symbols
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        echo "🔍 Checking for debug symbols..."
        for binary in target/release/*; do
          if [[ -x "$binary" && ! -d "$binary" ]]; then
            if file "$binary" | grep -q "not stripped"; then
              echo "::warning::Binary contains debug symbols: $binary"
            else
              echo "✅ Binary is properly stripped: $binary"
            fi
          fi
        done

    - name: Upload binary analysis results
      if: ${{ steps.rust.outputs.has == 'true' && hashFiles('binary-secrets.txt') != '' }}
      uses: actions/upload-artifact@$(get_action_sha "$ACTIONS_UPLOAD_ARTIFACT_V4") # $(get_action_version "$ACTIONS_UPLOAD_ARTIFACT_V4")
      with:
        name: binary-analysis-results
        path: binary-secrets.txt

  dependency-confusion-check:
    name: Dependency Confusion Detection
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")

    - name: Check for suspicious dependency names
      run: |
        echo "🔍 Checking for potential dependency confusion attacks..."
        
        # Extract dependency names from Cargo.toml
        if [[ -f "Cargo.toml" ]]; then
          echo "Dependencies found in Cargo.toml:"
          grep -E "^\s*[a-zA-Z0-9_-]+\s*=" Cargo.toml | head -10
          
          # Check for common typosquatting patterns
          SUSPICIOUS=""
          while IFS= read -r dep; do
            dep_name=$(echo "$dep" | sed 's/^\s*//' | cut -d'=' -f1 | tr -d ' ')
            # Check for suspicious patterns (numbers at end, common typos)
            if echo "$dep_name" | grep -E ".*[0-9]+$|.*-rs$|.*_rs$" >/dev/null; then
              SUSPICIOUS="$SUSPICIOUS $dep_name"
            fi
          done < <(grep -E "^\s*[a-zA-Z0-9_-]+\s*=" Cargo.toml)
          
          if [[ -n "$SUSPICIOUS" ]]; then
            echo "::warning::Potentially suspicious dependency names detected:"
            for dep in $SUSPICIOUS; do
              echo "  - $dep"
            done
            echo "Review these dependencies for typosquatting attempts"
          else
            echo "✅ No obviously suspicious dependency names detected"
          fi
        fi

    - name: Verify official crates.io sources
      run: |
        echo "🔍 Verifying dependency sources..."
        
        # Check if any dependencies are from non-standard sources
        if grep -E "git\s*=|path\s*=" Cargo.toml >/dev/null 2>&1; then
          echo "::notice::Found dependencies from non-crates.io sources:"
          grep -E "git\s*=|path\s*=" Cargo.toml || true
          echo "Ensure these are from trusted sources"
        else
          echo "✅ All dependencies appear to be from crates.io"
        fi

  enhanced-security-checks:
    name: Enhanced Security Validation
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")

    - name: Detect Rust packages
      id: rust
      run: |
        set -euo pipefail
        if [ -f Cargo.toml ]; then
          if grep -q '^[[:space:]]*\[package\]' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          elif grep -q '^[[:space:]]*\[workspace\]' Cargo.toml && grep -q '^[[:space:]]*members[[:space:]]*=' Cargo.toml; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi
        else
          echo "has=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Install Rust toolchain
      if: ${{ steps.rust.outputs.has == 'true' }}
      uses: dtolnay/rust-toolchain@$(get_action_sha "$DTOLNAY_RUST_TOOLCHAIN") # $(get_action_version "$DTOLNAY_RUST_TOOLCHAIN")
      with:
        toolchain: stable

    - name: Validate Cargo.lock
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        echo "🔍 Validating Cargo.lock..."
        if [[ ! -f "Cargo.lock" ]]; then
          echo "::error::Cargo.lock not found - this is required for reproducible builds"
          exit 1
        fi
        
        # Check if Cargo.lock is up-to-date
        if ! cargo check --locked >/dev/null 2>&1; then
          echo "::error::Cargo.lock is out of date"
          echo "Run 'cargo update' to update Cargo.lock"
          exit 1
        fi
        echo "✅ Cargo.lock is valid and up-to-date"

    - name: Check for feature flag security
      if: ${{ steps.rust.outputs.has == 'true' }}
      run: |
        echo "🔍 Checking feature flag configuration..."
        
        # Check for debug features that might be enabled inappropriately
        if grep -E "debug.*=.*true|dev.*=.*true" Cargo.toml >/dev/null 2>&1; then
          echo "::warning::Debug/dev features found in Cargo.toml"
          grep -E "debug.*=.*true|dev.*=.*true" Cargo.toml || true
          echo "Ensure debug features are not enabled in production builds"
        fi
        
        # Check for default features that might expose debug functionality
        if cargo tree --format "{f}" | grep -i debug >/dev/null 2>&1; then
          echo "::notice::Debug-related features detected in dependency tree"
          echo "Review feature flags for production appropriateness"
          else
            echo "✅ No obvious debug features in dependency tree"
          fi

    - name: Skip Enhanced Security (no Rust packages)
      if: ${{ steps.rust.outputs.has != 'true' }}
      run: echo "No Rust packages detected; skipping Enhanced Security job steps."

  gitsign-verification:
    name: Commit Signature Verification
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@$(get_action_sha "$ACTIONS_CHECKOUT_V4") # $(get_action_version "$ACTIONS_CHECKOUT_V4")
      with:
        fetch-depth: 0

    - name: Install Go
      uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
      with:
        go-version: '1.21'

    - name: Install gitsign for Sigstore verification
      run: |
        # Install gitsign for Sigstore signature verification
        go install github.com/sigstore/gitsign@latest

    - name: Verify latest commit signature
      run: |
        echo "Checking commit signature for: $(git log -1 --format='%H %s')"
        if git log --show-signature -1 2>&1 | grep -q "gitsign: Good signature"; then
          echo "✅ Latest commit has valid Sigstore signature"
        elif git log --show-signature -1 2>&1 | grep -q "gitsign: "; then
          echo "::error::Latest commit has invalid Sigstore signature"
          git log --show-signature -1
          exit 1
        else
          echo "::warning::Commit is not signed with Sigstore - enable gitsign"
        fi


  # =============================================================================
  # SHA PINNING VALIDATION (merged from pinning-validation.yml)
  # =============================================================================

  pinning:
    name: Validate GitHub Actions SHA Pinning
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Quick local pincheck (if present)
        run: |
          if [ -x ./.security-controls/bin/pinactlite ]; then
            ./.security-controls/bin/pinactlite pincheck --dir .github/workflows
          else
            echo "Local pinactlite helper not present; skipping quick check."
          fi

      - name: Install and verify tools, then install pinact v3.4.2
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.local/bin"
          export PATH="$HOME/.local/bin:$PATH"

          # 1) Install cosign v2.6.0 and verify with SHA256
          COSIGN_VERSION=v2.6.0
          COSIGN_BASE="https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}"
          COSIGN_BIN="cosign-linux-amd64"
          COSIGN_SHA="ea5c65f99425d6cfbb5c4b5de5dac035f14d09131c1a0ea7c7fc32eab39364f9"
          curl -fsSLo /tmp/${COSIGN_BIN} "${COSIGN_BASE}/${COSIGN_BIN}"
          echo "${COSIGN_SHA}  /tmp/${COSIGN_BIN}" | sha256sum -c -
          install -m 0755 /tmp/${COSIGN_BIN} "$HOME/.local/bin/cosign"

          # 2) Install slsa-verifier v2.7.1 and verify SHA256
          SLSA_VERIFIER_VERSION=v2.7.1
          SLSA_BIN="slsa-verifier-linux-amd64"
          SLSA_BASE="https://github.com/slsa-framework/slsa-verifier/releases/download/${SLSA_VERIFIER_VERSION}"
          SLSA_SHA="946dbec729094195e88ef78e1734324a27869f03e2c6bd2f61cbc06bd5350339"
          curl -fsSLo /tmp/${SLSA_BIN} "${SLSA_BASE}/${SLSA_BIN}"
          echo "${SLSA_SHA}  /tmp/${SLSA_BIN}" | sha256sum -c -
          install -m 0755 /tmp/${SLSA_BIN} "$HOME/.local/bin/slsa-verifier"

          # 3) Download pinact v3.4.2 artifacts and verify signature + provenance + checksum
          VERSION=v3.4.2
          BASE="https://github.com/suzuki-shunsuke/pinact/releases/download/${VERSION}"

          # Fetch checksums and signature
          curl -fsSLo /tmp/checksums.txt "${BASE}/pinact_${VERSION#v}_checksums.txt" || \
          curl -fsSLo /tmp/checksums.txt "${BASE}/checksums.txt"

          curl -fsSLo /tmp/checksums.txt.pem "${BASE}/pinact_${VERSION#v}_checksums.txt.pem" || \
          curl -fsSLo /tmp/checksums.txt.pem "${BASE}/checksums.txt.pem"

          curl -fsSLo /tmp/checksums.txt.sig "${BASE}/pinact_${VERSION#v}_checksums.txt.sig" || \
          curl -fsSLo /tmp/checksums.txt.sig "${BASE}/checksums.txt.sig"

          # Sigstore verification
          cosign verify-blob \
            --certificate /tmp/checksums.txt.pem \
            --signature /tmp/checksums.txt.sig \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            --certificate-identity-regexp '^https://github.com/suzuki-shunsuke/(pinact|go-release-workflow)/.*' \
            /tmp/checksums.txt

          # OpenSSL verification as defense in depth
          if ! openssl x509 -in /tmp/checksums.txt.pem -pubkey -noout > /tmp/pinact.pub 2>/dev/null; then
            base64 -d /tmp/checksums.txt.pem > /tmp/checksums.txt.pem.dec
            openssl x509 -in /tmp/checksums.txt.pem.dec -pubkey -noout > /tmp/pinact.pub
          fi
          if ! base64 -d /tmp/checksums.txt.sig > /tmp/checksums.txt.sig.bin 2>/dev/null; then
            cp /tmp/checksums.txt.sig /tmp/checksums.txt.sig.bin
          fi
          openssl dgst -sha256 -verify /tmp/pinact.pub -signature /tmp/checksums.txt.sig.bin /tmp/checksums.txt

          # Determine Linux amd64 tarball name
          TARBALL=""
          for name in "pinact_${VERSION#v}_linux_amd64.tar.gz" "pinact_linux_amd64.tar.gz" \
                     "pinact_${VERSION#v}_Linux_x86_64.tar.gz" "pinact_Linux_x86_64.tar.gz"; do
            if grep -q " ${name}$" /tmp/checksums.txt; then
              TARBALL="$name"; break
            fi
          done
          if [[ -z "$TARBALL" ]]; then
            echo "Unable to determine tarball name" >&2
            cat /tmp/checksums.txt >&2
            exit 1
          fi

          # Download and verify tarball
          curl -fsSLo "/tmp/${TARBALL}" "${BASE}/${TARBALL}"
          awk -v tar="${TARBALL}" -v path="/tmp/${TARBALL}" '$2==tar { print $1, path }' /tmp/checksums.txt | sha256sum -c -

          # Try SLSA provenance verification
          PROV=""
          for prov in multiple.intoto.jsonl provenance.intoto.jsonl attestation.intoto.jsonl; do
            if curl -fsSLo "/tmp/${prov}" "${BASE}/${prov}"; then PROV="/tmp/${prov}"; break; fi
          done

          if [[ -n "${PROV}" ]]; then
            slsa-verifier verify-artifact \
              --provenance-path "${PROV}" \
              --source-uri github.com/suzuki-shunsuke/pinact \
              --source-tag "${VERSION}" \
              "/tmp/${TARBALL}"
          fi

          # Extract and install
          tar -xzf "/tmp/${TARBALL}"
          install -m 0755 pinact "$HOME/.local/bin/pinact"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Verify pinact version
        run: pinact --version || true

      - name: Auto-fix unpinned actions with pinact
        id: pinact_fix
        run: |
          pinact run

          if git diff --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "✅ All actions are already pinned"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "📌 Auto-pinned actions:"
            git diff --stat
          fi

      - name: Commit auto-pinned changes
        if: steps.pinact_fix.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add .github/workflows/
          git commit -m "chore: auto-pin GitHub Actions to SHA

Auto-pinned by pinact v3.4.2 via 1cgs-security workflow

🤖 Generated with [Claude Code](https://claude.com/claude-code)"

      - name: Push auto-pinned changes
        if: steps.pinact_fix.outputs.changed == 'true'
        uses: ad-m/github-push-action@77c5b412c50b723d2a4fbc6d71fb5723bcd439aa # master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}

      - name: Alert about auto-fixed pins
        if: steps.pinact_fix.outputs.changed == 'true'
        run: |
          echo "::warning::Unpinned actions were detected and automatically fixed."
          exit 0
